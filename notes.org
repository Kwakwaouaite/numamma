* <2017-07-13 Thu> telconf F. Trahay + K. Marquet + L. Morel

Francois        raconte       comment        fonctionne       numaMMa:
https://fusionforge.int-evry.fr/projects/numma/

En gros: 
- on lance l'appli avec numamma
- ça utilise ldpreload pour intercepter malloc (et pthread_create)
- à chaque  malloc, ça enregistre l'adresse,  la taille, le nom  de la
  variable 
- ça le fait aussi pour les variables globales allouées statiquement
- Puis ça lance du sampling avec numap
- Lorsque  free est  appelée sur  un  de ces  variables (ou  lorsqu'un
  thread termine),  ça regarde les  samples et ça retrouve  les buffer
  associés à la zone libéré / le thread terminé
- Ça m-à-j  le nb d'accès  et les infos  de localisation des  accès en
  question.
- numamma cumule ces infos jusqu'à la fin de l'appli
- à la fin, numamma sort des stats. 


L'idée qu'a  François et qu'il  propose qu'on bosse  ensemble consiste
à : 
1- logguer une appli 1 fois avec numamma
2- lors des lancements ultérieurs de  la même appli: 
  - fournir les infos loggués (sous une forme à déterminer, cf plus loin)
  - intercepter les appels à malloc et pthread_create pour prendre les
    bonnes  informations  de  placement  des  données  et  threads  en
    fonction des info mesurée par numamma lors de la première exec. 



TODO pour la suite: 
- [ ]  Identifier les applis  à benchmarker.  openMP ? dataflow  ? Les
  mêmes que Carrefour ?
- [ ] construire des représentations graphiques pour : 
  - le placement  des données  et des threads  par défaut  (à observer
    lors de la phase d'exécution avec numamma)
  - l'intensité des échanges de données. Question : faut-il distinguer
    les read des writes
- [ ] faire  le binding  (placement "intelligent"  en fonction  de ce
  qu'on observe  avec les  représentations graphiques construite  à la
  phase d'avant)
- [ ] automatiser


Next meeting : 7 septembre 2017 @ 10h. Skype
